 t = out$t
 g[6] = NA; ########## change this !!!!!!!!!
 g.min = min(g);
 g.max = max(g);
# fm.log.g <- gnls( g ~ (g.max - g.min) / ( 1 + ( t / v )^ w ) + g.min, start = list( v = 5, w = 4 )  );
 fm.log.g <- gnls( g ~ (1 - 0.49) / ( 1 + ( t / v )^ w ) + 0.49, start = list( v = 5, w = 10 )  );
 g = out$g
 t = out$t
 g[6] = g[5] /2  + g[4] /2 ; ########## change this !!!!!!!!!
 g.min = min(g);
 g.max = max(g);
# fm.log.g <- gnls( g ~ (g.max - g.min) / ( 1 + ( t / v )^ w ) + g.min, start = list( v = 5, w = 4 )  );
 fm.log.g <- gnls( g ~ (1 - 0.49) / ( 1 + ( t / v )^ w ) + 0.49, start = list( v = 5, w = 10 )  );
 fm.log.g # this the half life T1/2 w_s
plot(s~t); points(g~t, col="red")
g
Pb
out$Pb
t
g
g = out$g
 t = out$t
 g[6] = g[5] /2  + g[4] /2 ; ########## change this !!!!!!!!!
 g[11] = NA; t[11]=NA;
 g[9] =NA; t[9]=NA;
 t = t[ ! is.na(t)];
 g = g[ ! is.na(g)];
 g.min = min(g);
 g.max = max(g);
# fm.log.g <- gnls( g ~ (g.max - g.min) / ( 1 + ( t / v )^ w ) + g.min, start = list( v = 5, w = 4 )  );
 fm.log.g <- gnls( g ~ (1 - 0.49) / ( 1 + ( t / v )^ w ) + 0.49, start = list( v = 5, w = 10 )  );
 fm.log.g # this the half life T1/2 w_s
 g = out$g
 t = out$t
 g[6] = g[5] /2  + g[4] /2 ; ########## change this !!!!!!!!!
 g[11] = NA; t[11]=NA;
 g[9] =NA; t[9]=NA;
 t = t[ ! is.na(t)];
 g = g[ ! is.na(g)];
 g.min = min(g);
 g.max = max(g);
# fm.log.g <- gnls( g ~ (g.max - g.min) / ( 1 + ( t / v )^ w ) + g.min, start = list( v = 5, w = 4 )  );
 fm.log.g <- gnls( g ~ (1 - 0.49) / ( 1 + ( t / v )^ w ) + 0.49, start = list( v = 5, w = 10 )  );
 fm.log.g # this the half life T1/2 w_s
 plot( s ~ t); points( g~t, col="red");
points(g ~ t, col="red");
 plot( s ~ t); points(g ~ t, col="red");
plot( s ~ t);
 g = out$g
 t = out$t
 g[6] = g[5] /2  + g[4] /2 ; ########## change this !!!!!!!!!
 g[11] = NA; t[11]=NA;
 g[9] =NA; t[9]=NA;
 s = s[ ! is.na(t)];
 t = t[ ! is.na(t)];
 g = g[ ! is.na(g)];
s
t
 g.min = min(g);
 g.max = max(g);
# fm.log.g <- gnls( g ~ (g.max - g.min) / ( 1 + ( t / v )^ w ) + g.min, start = list( v = 5, w = 4 )  );
 fm.log.g <- gnls( g ~ (1 - 0.49) / ( 1 + ( t / v )^ w ) + 0.49, start = list( v = 5, w = 10 )  );
 fm.log.g # this the half life T1/2 w_s
 plot( s ~ t); points(g ~ t, col="red");
 fm.log.g <- gnls( g ~ (1 - 0.49) / ( 1 + ( t / v )^ w ) + 0.49, start = list( v = 5, w = 10 )  );
 fm.log.g # this the half life T_g w_g
 plot( s ~ t); points(g ~ t, col="red");
 one = 1;
 fm.log.g <- gnls( g ~ (one - 0.49) / ( 1 + ( t / v )^ w ) + 0.49, start = list( v = 5, w = 10 )  );
 fm.log.g # this the half life T_g w_g
?gnls
library(nlme)
rm(list=ls());
logistical.viability <- function( v, w, t ) { ret <- 1 /( 1 + ( t / v )^ w );  }
file = "060306.rad52DD1.tab";
tb= read.table( file, header=T, sep="\t", fill=T);
tb$t = tb$t / 24;
tb2 = tb;
labels = names( tb );
#normalize tb2
 for( j in 5:13 ) {
   for( i in  1: length(tb2[,1]) ) {
     if ( is.na(tb2[i,j] ) ) { tb2[i,j] = 0; }
     tb2[i,j] = tb2[i,j] * tb2[i,2] * tb2[i,3];
   }
 }
#generate row indice for averaging
 # row.num = c( 2, 3, 5, 6, 8, 9:15 );
 row.steps = as.vector( table( tb2$t ) ); # a new trick, ha
#generate tb.m
 n.row = length( row.steps );
 col.labels = c( labels[ c(1, 5:13) ], "total" );
 #col.end = 11;
 tb.m = data.frame( matrix( nrow=n.row, ncol= length(col.labels) ) )  # mean values
 names( tb.m ) = col.labels; 
 upper.row = 0; #up pointer
 lower.row = 0; #low pointer 
 for( i in 1:n.row ) {   # for( i in 1: length(tb.m[,1]) ) {
   upper.row = lower.row + 1;
   lower.row = upper.row + row.steps[ i ] - 1 ;
   tb.m[i,1]  = tb2$t[ upper.row ]
   for( j in 2: ( length(col.labels) - 1 ) ) {
     # tb.m[i, j] = mean( tb2[ c(3*i-2, 3*i-1, 3*i), j+3] )
     tb.m[i, j] = mean( tb2[ upper.row : lower.row, j+3] )
   }
   tb.m$total[i] = sum( tb.m[i, 2:( length(col.labels) - 1 )], na.rm=T );
 }
ls()
tb
tb2
tb.m
 header = c("t","half.over.black","Pb","Rb","R0.5", "R0.75", "s", "g" );
 out = data.frame( matrix( nrow= length(tb.m[,1]) , ncol= length(header) ) );
 names( out ) = header;
 out$t = tb.m$t; # "t"
#######calculate s , g
  for( i in length(out[,1]):1 ) { #row
    out$s[i]  = tb.m$total[i]    / tb.m$total[1]; #s
    #out[i,2] = tb.m$B0.5[i]     / tb.m$black[i];   
    out$Pb[i] = tb.m$black[i] / tb.m$total[i];
    out$g[i]  = 1 - 2 * out$Pb[i];
  }
out
plot( s ~ t, type="l")
attach(out); plot( s ~ t, type="l")
lines( g ~ t, col="blue")
lines( Pb ~ t, col="red")
######## calclulate T_g and w_g
 g = out$g
 t = out$t
 g[6] = g[5] /2  + g[4] /2 ; ########## change this !!!!!!!!!
 g[11] = NA; t[11]=NA;
 g[9] =NA; t[9]=NA;
 s = s[ ! is.na(t)];
 t = t[ ! is.na(t)];
 g = g[ ! is.na(g)];
 g.min = min(g);
 g.max = max(g);
# fm.log.g <- gnls( g ~ (g.max - g.min) / ( 1 + ( t / v )^ w ) + g.min, start = list( v = 5, w = 4 )  );
# one = 1;
# fm.log.g <- gnls( g ~ (one - 0.49) / ( 1 + ( t / v )^ w ) + 0.49, params= , start = list( v = 5, w = 10 )  );
# how to use params to control gnls??? how about other functions?
 fm.log.g <- gnls( g ~ (1 - 0.49) / ( 1 + ( t / v )^ w ) + 0.49,  start = list( v = 5, w = 10 )  );
 fm.log.g # this the half life T_g w_g
ls();
tb
tb.m
out
     DNase1 <- subset(DNase, Run == 1)
     ## using a selfStart model
     fm1DNase1 <- gnls(density ~ SSlogis(log(conc), Asym, xmid, scal), DNase1)
     summary(fm1DNase1)
library(nlme)
     DNase1 <- subset(DNase, Run == 1)
     ## using a selfStart model
     fm1DNase1 <- gnls(density ~ SSlogis(log(conc), Asym, xmid, scal), DNase1)
     summary(fm1DNase1)
     fm1DNase2 <- nls(density ~ SSlogis(log(conc), Asym, xmid, scal), DNase1)
     summary(fm1DNase1)
     summary(fm1DNase2)
     fm1DNase1 <- nls(density ~ SSlogis(log(conc), Asym, xmid, scal), DNase1)
     summary(fm1DNase1)
     fm1DNase2 <- nls(density ~ SSlogis(log(conc), Asym, xmid, scal), DNase1)
     summary(fm1DNase2)
     summary(fm1DNase1)
#######################################
     summary(fm1DNase2)
     summary(fm1DNase1)
     summary(fm1DNase1)
     summary(fm1DNase2)
     summary(fm1DNase2)
     fm1DNase1 <- nls(density ~ SSlogis(log(conc), Asym, xmid, scal), DNase1)
     summary(fm1DNase1)
     fm1DNase2 <- gnls(density ~ SSlogis(log(conc), Asym, xmid, scal), DNase1)
     summary(fm1DNase2)
fm1DNase1
fm1DNase2
fm1DNase2
str(fm1DNase2)
     ## using conditional linearity
     fm2DNase1 <- nls(density ~ 1/(1 + exp((xmid - log(conc))/scal)),
                      data = DNase1,
                      start = list(xmid = 0, scal = 1),
                      alg = "plinear", trace = TRUE)
     summary(fm2DNase1)
     summary(fm2DNase1)
     fm2DNase1.b <- gnls(density ~ 1/(1 + exp((xmid - log(conc))/scal)),
                      data = DNase1,
                      start = list(xmid = 0, scal = 1),
                      alg = "plinear", trace = TRUE)
     summary(fm2DNase1.b)
     fm2DNase1.b <- gnls(density ~ 1/(1 + exp((xmid - log(conc))/scal)),
                      data = DNase1,
                      start = list(xmid = 0, scal = 1),
                #      alg = "plinear", 
trace = TRUE)
     fm2DNase1.b <- gnls(density ~ 1/(1 + exp((xmid - log(conc))/scal)),
                      data = DNase1,
                      start = list(xmid = 0, scal = 1) )
DNase1[1:10,]
library(nlme)
rm(list=ls());
file = "060306.rad52DD1.tab";
logistical.viability <- function( v, w, t ) { ret <- 1 /( 1 + ( t / v )^ w );  }
tb= read.table( file, header=T, sep="\t", fill=T);
tb$t = tb$t / 24;
tb2 = tb;
labels = names( tb );
#normalize tb2
 for( j in 5:13 ) {
   for( i in  1: length(tb2[,1]) ) {
     if ( is.na(tb2[i,j] ) ) { tb2[i,j] = 0; }
     tb2[i,j] = tb2[i,j] * tb2[i,2] * tb2[i,3];
   }
 }
#generate row indice for averaging
 # row.num = c( 2, 3, 5, 6, 8, 9:15 );
 row.steps = as.vector( table( tb2$t ) ); # a new trick, ha
#generate tb.m
 n.row = length( row.steps );
 col.labels = c( labels[ c(1, 5:13) ], "total" );
 #col.end = 11;
 tb.m = data.frame( matrix( nrow=n.row, ncol= length(col.labels) ) )  # mean values
 names( tb.m ) = col.labels; 
 upper.row = 0; #up pointer
 lower.row = 0; #low pointer 
 for( i in 1:n.row ) {   # for( i in 1: length(tb.m[,1]) ) {
   upper.row = lower.row + 1;
   lower.row = upper.row + row.steps[ i ] - 1 ;
   tb.m[i,1]  = tb2$t[ upper.row ]
   for( j in 2: ( length(col.labels) - 1 ) ) {
     # tb.m[i, j] = mean( tb2[ c(3*i-2, 3*i-1, 3*i), j+3] )
     tb.m[i, j] = mean( tb2[ upper.row : lower.row, j+3] )
   }
   tb.m$total[i] = sum( tb.m[i, 2:( length(col.labels) - 1 )], na.rm=T );
 }
# output to out,
# columns in out
 header = c("t","half.over.black","Pb","Rb","R0.5", "R0.75", "s", "g" );
 out = data.frame( matrix( nrow= length(tb.m[,1]) , ncol= length(header) ) );
 names( out ) = header;
 out$t = tb.m$t; # "t"
#######calculate s , g
  for( i in length(out[,1]):1 ) { #row
    out$s[i]  = tb.m$total[i]    / tb.m$total[1]; #s
    #out[i,2] = tb.m$B0.5[i]     / tb.m$black[i];   
    out$Pb[i] = tb.m$black[i] / tb.m$total[i];
    out$g[i]  = 1 - 2 * out$Pb[i];
  }
 #postscript("060306.rad52D.1.ps")
 plot( out$s ~ out$t , type='l', main= file, col="blue");
 lines( out$Pb ~ out$t, col="black");
 labels = c("viability","black");
 ltypes = c(1,1);
 legend( (max(out$t)*0.7 ), 0.8, labels, col=c("blue", "black"), lty = ltypes);
 
out
out[6,] = NA;
out
out = out[ (! in.na(tb$t)), ]
out = out[ (! is.na(tb$t) ), ]
out
is.na( out$t)
 out = data.frame( matrix( nrow= length(tb.m[,1]) , ncol= length(header) ) );
 names( out ) = header;
 out$t = tb.m$t; # "t"
#######calculate s , g
  for( i in length(out[,1]):1 ) { #row
    out$s[i]  = tb.m$total[i]    / tb.m$total[1]; #s
    #out[i,2] = tb.m$B0.5[i]     / tb.m$black[i];   
    out$Pb[i] = tb.m$black[i] / tb.m$total[i];
    out$g[i]  = 1 - 2 * out$Pb[i];
  }
 #postscript("060306.rad52D.1.ps")
 plot( out$s ~ out$t , type='l', main= file, col="blue");
 lines( out$Pb ~ out$t, col="black");
 labels = c("viability","black");
 ltypes = c(1,1);
 legend( (max(out$t)*0.7 ), 0.8, labels, col=c("blue", "black"), lty = ltypes);
 
####### remove outliers#######################
out[6,] = NA;
out
out = out[ (! is.na(out$t) ), ]
out
 t= out$t
 s= out$s
 fm.log.s <- gnls( s ~ 1 /( 1 + ( t / v )^ w ) , start = list( v = 5, w = 4 )  );
 fm.log.s # this the half life T1/2 w_s
 g = out$g
 t = out$t
 g.min = min(g);
 g.max = max(g);
# fm.log.g <- gnls( g ~ (g.max - g.min) / ( 1 + ( t / v )^ w ) + g.min, start = list( v = 5, w = 4 )  );
# one = 1;
# fm.log.g <- gnls( g ~ (one - 0.49) / ( 1 + ( t / v )^ w ) + 0.49, params= , start = list( v = 5, w = 10 )  );
# how to use params to control gnls??? how about other functions?
 fm.log.g <- gnls( g ~ (1 - 0.49) / ( 1 + ( t / v )^ w ) + 0.49,  start = list( v = 5, w = 10 )  );
 fm.log.g # this the half life T_g w_g
plot(g~t)
plot(Pb~t)
plot(out$Pb~out$t)
 b = out$Pb
 t = out$t;
 b.min = min( b ); b.min
 b.max = max( b ); b.max
 fm.b = gnls( b ~ 0.25504 - (0.25504 - 0.1688) / (1 + (t/T.g)^w ), start=list( T.g=2, w=5) );
fm.b
plot(fm.b)
logistical.black     <- function(b.max, b.min, T, w, t ) { ret <- b.max - (b.max - b.min) /( 1 + ( t / T )^ w );  }
fm.b$coefficients
logistical.black     <- function(b.max, b.min, T, w, t ) { ret <- b.max - (b.max - b.min) /( 1 + ( t / T )^ w );  }
 t = seq(0,10,by=0.1);
 fit.b = logistical.black( b.max, b.min, fm.b$coefficients[1], fm.b$coefficients[2], t);
lines( fit.b ~ t, col="blue");
 plot( out$b ~ out$t );
 lines( fit.b ~ t, col="blue");
 
 plot( out$Pb ~ out$t );
 lines( fit.b ~ t, col="blue");
 t = seq(0, max(out$t),by=0.1);
 fit.b = logistical.black( b.max, b.min, fm.b$coefficients[1], fm.b$coefficients[2], t);
 
 plot( out$Pb ~ out$t );
 lines( fit.b ~ t, col="blue");
 plot( s ~ t); points( g ~ t, col="red" );
 t= out$t
 s= out$s
 fm.s <- gnls( s ~ 1 /( 1 + ( t / v )^ w ) , start = list( v = 5, w = 4 )  );
 fm.s # this the half life T1/2 w_s
 t = seq(0, max(out$t),by=0.1);
 fit.s = logistical.viability ( fm.s$coefficients[1], fm.s$coefficients[2], t );
 t= out$t
 s= out$s
 fm.s <- gnls( s ~ 1 /( 1 + ( t / v )^ w ) , start = list( v = 5, w = 4 )  );
 fm.s # this the half life T1/2 w_s
 t = seq(0, max(out$t),by=0.1);
 fit.s = logistical.viability ( fm.s$coefficients[1], fm.s$coefficients[2], t );
 plot( out$s ~ out$t );
 lines( fit.s ~ t, col="blue");
plot(fit.s)
plot(fm.s)
 
 plot( out$Pb ~ out$t );
 lines( fit.b ~ t, col="blue");
rm(list=ls());
library(nlme)
file = "060306.rad52DD1.tab";
logistical.viability <- function( T, w, t ) { ret <- 1 /( 1 + ( t / T )^ w );  }
logistical.black     <- function(b.max, b.min, T, w, t ) { ret <- b.max - (b.max - b.min) /( 1 + ( t / T )^ w );  }
tb= read.table( file, header=T, sep="\t", fill=T);
tb$t = tb$t / 24;
tb2 = tb;
labels = names( tb );
#normalize tb2
 for( j in 5:13 ) {
   for( i in  1: length(tb2[,1]) ) {
     if ( is.na(tb2[i,j] ) ) { tb2[i,j] = 0; }
     tb2[i,j] = tb2[i,j] * tb2[i,2] * tb2[i,3];
   }
 }
#generate row indice for averaging
 # row.num = c( 2, 3, 5, 6, 8, 9:15 );
 row.steps = as.vector( table( tb2$t ) ); # a new trick, ha
#generate tb.m
 n.row = length( row.steps );
 col.labels = c( labels[ c(1, 5:13) ], "total" );
 #col.end = 11;
 tb.m = data.frame( matrix( nrow=n.row, ncol= length(col.labels) ) )  # mean values
 names( tb.m ) = col.labels; 
 upper.row = 0; #up pointer
 lower.row = 0; #low pointer 
 for( i in 1:n.row ) {   # for( i in 1: length(tb.m[,1]) ) {
   upper.row = lower.row + 1;
   lower.row = upper.row + row.steps[ i ] - 1 ;
   tb.m[i,1]  = tb2$t[ upper.row ]
   for( j in 2: ( length(col.labels) - 1 ) ) {
     # tb.m[i, j] = mean( tb2[ c(3*i-2, 3*i-1, 3*i), j+3] )
     tb.m[i, j] = mean( tb2[ upper.row : lower.row, j+3] )
   }
   tb.m$total[i] = sum( tb.m[i, 2:( length(col.labels) - 1 )], na.rm=T );
 }
# output to out,
# columns in out
 header = c("t","half.over.black","Pb","Rb","R0.5", "R0.75", "s", "g" );
 out = data.frame( matrix( nrow= length(tb.m[,1]) , ncol= length(header) ) );
 names( out ) = header;
 out$t = tb.m$t; # "t"
#######calculate s , g
  for( i in length(out[,1]):1 ) { #row
    out$s[i]  = tb.m$total[i]    / tb.m$total[1]; #s
    #out[i,2] = tb.m$B0.5[i]     / tb.m$black[i];   
    out$Pb[i] = tb.m$black[i] / tb.m$total[i];
    out$g[i]  = 1 - 2 * out$Pb[i];
  }
 #postscript("060306.rad52D.1.ps")
 plot( out$s ~ out$t , type='l', main= file, col="blue");
 lines( out$Pb ~ out$t, col="black");
 labels = c("viability","black");
 ltypes = c(1,1);
 legend( (max(out$t)*0.7 ), 0.8, labels, col=c("blue", "black"), lty = ltypes);
####### remove outliers#######################
 #out[6,] = NA;
 #out = out[ (! is.na(out$t) ), ]
######## calclulate T0.5 w_s
 t= out$t
 s= out$s
 fm.s <- gnls( s ~ 1 /( 1 + ( t / v )^ w ) , start = list( v = 5, w = 4 )  );
 fm.s # this the half life T1/2 w_s
 t = seq(0, max(out$t),by=0.1);
 fit.s = logistical.viability ( fm.s$coefficients[1], fm.s$coefficients[2], t );
 plot( out$s ~ out$t );
 lines( fit.s ~ t, col="blue");
# Pb = b.max - (b.max-b.min) / (1 + (t/T.g)^w)
 b = out$Pb
 t = out$t;
 b.min = min( b ); b.min  #0.1688
 b.max = max( b ); b.max  #0.25504
 fm.b = gnls( b ~ 0.25504 - (0.25504 - 0.1688) / (1 + (t/T.g)^w ), start=list( T.g=2, w=5) );
 fm.b
 plot( fm.b );
 t = seq(0, max(out$t),by=0.1);
 fit.b = logistical.black( b.max, b.min, fm.b$coefficients[1], fm.b$coefficients[2], t);
 
 plot( out$Pb ~ out$t );
 lines( fit.b ~ t, col="blue");
out
tb
# remove outlier?
rm(list=ls());
library(nlme)
file = "060306.rad52DD1.tab";
logistical.viability <- function( T, w, t ) { ret <- 1 /( 1 + ( t / T )^ w );  }
logistical.black     <- function(b.max, b.min, T, w, t ) { ret <- b.max - (b.max - b.min) /( 1 + ( t / T )^ w );  }
tb= read.table( file, header=T, sep="\t", fill=T);
tb$t = tb$t / 24;
tb2 = tb;
labels = names( tb );
#normalize tb2
 for( j in 5:13 ) {
   for( i in  1: length(tb2[,1]) ) {
     if ( is.na(tb2[i,j] ) ) { tb2[i,j] = 0; }
     tb2[i,j] = tb2[i,j] * tb2[i,2] * tb2[i,3];
   }
 }
#generate row indice for averaging
 # row.num = c( 2, 3, 5, 6, 8, 9:15 );
 row.steps = as.vector( table( tb2$t ) ); # a new trick, ha
#generate tb.m
 n.row = length( row.steps );
 col.labels = c( labels[ c(1, 5:13) ], "total" );
 #col.end = 11;
 tb.m = data.frame( matrix( nrow=n.row, ncol= length(col.labels) ) )  # mean values
 names( tb.m ) = col.labels; 
 upper.row = 0; #up pointer
 lower.row = 0; #low pointer 
 for( i in 1:n.row ) {   # for( i in 1: length(tb.m[,1]) ) {
   upper.row = lower.row + 1;
   lower.row = upper.row + row.steps[ i ] - 1 ;
   tb.m[i,1]  = tb2$t[ upper.row ]
   for( j in 2: ( length(col.labels) - 1 ) ) {
     # tb.m[i, j] = mean( tb2[ c(3*i-2, 3*i-1, 3*i), j+3] )
     tb.m[i, j] = mean( tb2[ upper.row : lower.row, j+3] )
   }
   tb.m$total[i] = sum( tb.m[i, 2:( length(col.labels) - 1 )], na.rm=T );
 }
# output to out,
# columns in out
 header = c("t","half.over.black","Pb","Rb","R0.5", "R0.75", "s", "g" );
 out = data.frame( matrix( nrow= length(tb.m[,1]) , ncol= length(header) ) );
 names( out ) = header;
 out$t = tb.m$t; # "t"
#######calculate s , g
  for( i in length(out[,1]):1 ) { #row
    out$s[i]  = tb.m$total[i]    / tb.m$total[1]; #s
    #out[i,2] = tb.m$B0.5[i]     / tb.m$black[i];   
    out$Pb[i] = tb.m$black[i] / tb.m$total[i];
    out$g[i]  = 1 - 2 * out$Pb[i];
  }
 #postscript("060306.rad52D.1.ps")
 plot( out$s ~ out$t , type='l', main= file, col="blue");
 lines( out$Pb ~ out$t, col="black");
 labels = c("viability","black");
 ltypes = c(1,1);
 legend( (max(out$t)*0.7 ), 0.8, labels, col=c("blue", "black"), lty = ltypes);
####### remove outliers#######################
 out[6,] = NA;
 out = out[ (! is.na(out$t) ), ]
######## calclulate T0.5 w_s
 t= out$t
 s= out$s
 fm.s <- gnls( s ~ 1 /( 1 + ( t / v )^ w ) , start = list( v = 5, w = 4 )  );
 fm.s # this the half life T1/2 w_s
 t = seq(0, max(out$t),by=0.1);
 fit.s = logistical.viability ( fm.s$coefficients[1], fm.s$coefficients[2], t );
 plot( out$s ~ out$t );
 lines( fit.s ~ t, col="blue");
######## calclulate T_g and w_g using Pb
 # Pb = b.max - (b.max-b.min) / (1 + (t/T.g)^w)
 b = out$Pb
 t = out$t;
 b.min = min( b ); b.min  #0.1688
 b.max = max( b ); b.max  #0.25504
 fm.b = gnls( b ~ 0.25504 - (0.25504 - 0.1688) / (1 + (t/T.g)^w ), start=list( T.g=2, w=5) );
 fm.b
 plot( fm.b );
 t = seq(0, max(out$t),by=0.1);
 fit.b = logistical.black( b.max, b.min, fm.b$coefficients[1], fm.b$coefficients[2], t);
 
 plot( out$Pb ~ out$t );
 lines( fit.b ~ t, col="blue");
# quit("yes");
